package postgres

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"

	"github.com/paula-dot/kenya-admin-boundaries-api/internal/domain"
)

// CountyRepo implements the service.CountyRepository interface.
type CountyRepo struct {
	// Querier is the interface generated by sqlc.
	// Using the interface rather than the concrete *Queries struct makes unit testing easier.
	db Querier
}

// NewCountyRepository creates a new PostgreSQL-backed county repository.
func NewCountyRepository(pool *pgxpool.Pool) *CountyRepo {
	return &CountyRepo{
		// New() is auto-generated by sqlc to wrap the connection pool
		db: New(pool),
	}
}

// GetCountyByID executes the SQL query and maps the result to the domain model.
func (r *CountyRepo) GetCountyByID(ctx context.Context, id uuid.UUID) (*domain.County, error) {
	// Call the sqlc-generated GetCountyByID method
	row, err := r.db.GetCountyByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("repository - GetCountyByID failed: %w", err)
	}

	// Map the database-specific struct to your pure domain model
	county := &domain.County{
		ID:        row.ID,
		Code:      row.Code,
		Name:      row.Name,
		Geometry:  row.GeoJSON, // This is the []byte cast from our ST_AsGeoJSON query
		CreatedAt: row.CreatedAt,
		UpdatedAt: row.UpdatedAt,
	}

	return county, nil
}

// ListCounties executes the list query and maps the slice of results to domain models.
func (r *CountyRepo) ListCounties(ctx context.Context) ([]*domain.County, error) {
	row, err := r.db.ListCounties(ctx)
	if err != nil {
		return nil, fmt.Errorf("repository - ListCounties failed: %w", err)
	}

	var counties []*domain.County
	for _, row := range rows {
		counties := &domain.County{
			ID:       row.ID,
			Code:     row.Code,
			Name:     row.Name,
			Geometry: row.GeoJSON,
		}
		counties = append(counties, county)
	}

	return counties, nil
}
